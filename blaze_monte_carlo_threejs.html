<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaze Intelligence Monte Carlo 3D Visualization</title>
  <style>
    /* Basic styling to center the canvas and overlay a small info box */
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
      background: #0b0b19;
      color: #eee;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.5);
      border-radius: 4px;
      z-index: 100;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Informational overlay -->
  <div id="info">
    <strong>Blaze Intelligence Monte Carlo</strong><br/>
    Interactive 3D bar charts for Monthly Value, ROI %, Profit Margin, Mean Revenue and Sensitivity.<br/>
    Use your mouse to rotate, zoom and pan the scene.
  </div>
  <script type="module">
    // Import Three.js and orbit controls as ES modules from a CDN.  Using the module
    // versions ensures modern bundlers and browsers can optimise delivery.
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // Data generated by monte_carlo.py and exported via Python.  The JSON structure
    // contains histograms for monthly value, ROI and profit margin, mean revenue
    // values for the four revenue streams, and sensitivity impact scores.  These
    // numbers were calculated from the simulation results and embedded directly
    // into this file so it can run standalone without additional data fetches.
    const data = {"monthly": {"centers": [21511.65091890385, 31602.94690064806, 41694.24288239227, 51785.538864136484, 61876.83484588069, 71968.1308276249, 82059.4268093691, 92150.72279111332, 102242.01877285754, 112333.31475460174, 122424.61073634595, 132515.90671809018, 142607.20269983436, 152698.49868157858, 162789.7946633228, 172881.090645067, 182972.38662681123, 193063.68260855542, 203154.97859029964, 213246.27457204385, 223337.57055378804, 233428.86653553226, 243520.16251727648, 253611.45849902066, 263702.7544807649, 273794.0504625091, 283885.3464442533, 293976.6424259975, 304067.9384077417], "counts": [39, 247, 653, 1031, 1238, 1337, 1214, 1043, 854, 655, 515, 363, 281, 167, 115, 96, 59, 34, 24, 17, 6, 5, 3, 1, 1, 0, 1, 0, 1]}, "roi": {"centers": [291.01855300334864, 438.7905371529573, 586.562521302566, 734.3345054521744, 882.1064896017831, 1029.8784737513918, 1177.6504579010002, 1325.4224420506089, 1473.1944262002175, 1620.9664103498262, 1768.738394499435, 1916.5103786490433, 2064.282362798652, 2212.0543469482606, 2359.8263310978693, 2507.598315247478, 2655.3702993970867, 2803.1422835466954, 2950.9142676963036, 3098.6862518459123, 3246.458235995521, 3394.2302201451296, 3542.0022042947383, 3689.774188444347, 3837.546172593956, 3985.3181567435646, 4133.090140893173, 4280.862125042782, 4428.63410919239], "counts": [103, 383, 806, 1064, 1222, 1100, 929, 749, 593, 468, 331, 236, 135, 108, 70, 60, 38, 27, 20, 12, 7, 7, 2, 1, 1, 0, 0, 0, 0]}, "profit_margin": {"centers": [0.6897364930542054, 0.6998605712038136, 0.7099846493534217, 0.7201087275030298, 0.730232805652638, 0.7403568838022461, 0.7504809619518542, 0.7606050401014623, 0.7707291182510705, 0.7808531964006786, 0.7909772745502867, 0.8011013526998948, 0.811225430849503, 0.8213495089991111, 0.8314735871487192, 0.8415976652983274, 0.8517217434479355, 0.8618458215975437, 0.8719698997471518, 0.8820939778967599, 0.892218056046368, 0.9023421341959763, 0.9124662123455845, 0.9225902904951926, 0.9327143686448007, 0.9428384467944088, 0.952962524944017, 0.9630866030936251, 0.9732106812432332], "counts": [2, 11, 36, 122, 281, 509, 652, 823, 992, 1054, 1039, 1002, 853, 720, 528, 382, 272, 153, 80, 36, 12, 8, 3, 1, 0, 0, 0, 0, 0]}, "mean_revenues": {"Subscription": 24234.19124811116, "API": 4274.045690464295, "Projects": 27200.171553974436, "Licensing": 12516.833939707836}, "sensitivity": {"factors": ["Project Revenue", "Licensing Revenue", "Subscription Revenue", "Api Revenue", "Automation Savings", "Total Costs"], "impact_scores": [0.3872464058606589, 0.1409439697916865, 0.06685122742291, 0.0433928820130966, 0.0065982425371913, 0.0040348215107536]}, "maxCount": 1348, "maxRevenue": 27200.171553974436, "maxSens": 0.3872464058606589};

    // Chart layout constants
    const barSpacing = 1.3;      // distance between adjacent bars in a group
    const groupSpacing = 5.0;    // distance between different chart groups
    const barDepth = 1.0;        // depth of each bar (z dimension)
    const barWidth = 1.0;        // width of each bar (x dimension)

    // Compute widths for each group based on bar count
    const monthlyWidth = data.monthly.counts.length * barSpacing;
    const roiWidth     = data.roi.counts.length     * barSpacing;
    const pmWidth      = data.profit_margin.counts.length * barSpacing;
    const revenueCount = Object.keys(data.mean_revenues).length;
    const revenueWidth = revenueCount * barSpacing;
    const sensCount    = data.sensitivity.factors.length;
    const sensWidth    = sensCount * barSpacing;
    // Total width across all groups and spacing between them
    const totalWidth = monthlyWidth + roiWidth + pmWidth + revenueWidth + sensWidth + groupSpacing * 4.0;
    // Starting x coordinate to centre the charts
    const startX = -totalWidth / 2.0;
    const monthlyOffset = startX;
    const roiOffset     = monthlyOffset + monthlyWidth + groupSpacing;
    const pmOffset      = roiOffset     + roiWidth     + groupSpacing;
    const revenueOffset = pmOffset      + pmWidth      + groupSpacing;
    const sensOffset    = revenueOffset + revenueWidth + groupSpacing;

    // Determine maxima for scaling heights.  If precomputed values are present in the JSON
    // use them, otherwise compute on the fly.  The +0.1 added later ensures bars are visible
    // even when the underlying value is zero.
    const maxCount = data.maxCount || Math.max(...data.monthly.counts, ...data.roi.counts, ...data.profit_margin.counts);
    const maxRevenue = data.maxRevenue || Math.max(...Object.values(data.mean_revenues));
    const sensScores = data.sensitivity.impact_scores.map(Number);
    const maxSens = data.maxSens || Math.max(...sensScores);

    // Set up renderer and attach to the document.  Enabling antialias improves visual
    // fidelity at the cost of some performance.
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a new Three.js scene and set a dark background for contrast
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b19);

    // Set up a perspective camera.  The field of view and near/far planes were
    // chosen empirically to frame all charts nicely.  The camera will be
    // repositioned automatically when the window is resized.
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 100);
    camera.lookAt(0, 0, 0);

    // Add orbit controls to allow interactive rotation, zooming and panning.  Damping
    // produces inertial movement for a more natural feel.
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;

    // Ambient light softly illuminates all surfaces equally
    const ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.6);
    scene.add(ambientLight);
    // Directional light simulates a distant light source; the position and intensity
    // were chosen to reveal depth and contours on the bars
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 50, 50);
    scene.add(directionalLight);

    /**
     * Helper to create a bar mesh.  Each bar is a BoxGeometry that sits on the
     * ground plane.  Bars are translated upward by half their height so that
     * their bases rest on y=0.  Colour is provided via a MeshPhongMaterial.
     *
     * @param {number} height - The height of the bar in world units
     * @param {THREE.Color | number | string} color - The colour of the bar
     * @returns {THREE.Mesh}
     */
    function createBar(height, color) {
      const geometry = new THREE.BoxGeometry(barWidth, height, barDepth);
      const material = new THREE.MeshPhongMaterial({ color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = height / 2.0;
      return mesh;
    }

    /**
     * Helper to create simple x and y axes for a bar chart group.  The axes are
     * drawn using LineBasicMaterial and BufferGeometry.  Only the horizontal x
     * axis and vertical y axis are drawn; tick marks and labels can be added
     * manually if desired.
     *
     * @param {number} width - The total width of the bar chart group (x dimension)
     * @param {number} maxHeight - The maximum height of the bars for the y-axis
     * @param {number} offsetX - The x offset where the axes start
     * @returns {THREE.Group}
     */
    function createAxes(width, maxHeight, offsetX) {
      const group = new THREE.Group();
      const material = new THREE.LineBasicMaterial({ color: 0x555555 });
      // X axis from offsetX to offsetX + width
      {
        const points = [];
        points.push(new THREE.Vector3(offsetX, 0, 0));
        points.push(new THREE.Vector3(offsetX + width, 0, 0));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        group.add(line);
      }
      // Y axis from 0 to maxHeight
      {
        const points = [];
        points.push(new THREE.Vector3(offsetX, 0, 0));
        points.push(new THREE.Vector3(offsetX, maxHeight, 0));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        group.add(line);
      }
      return group;
    }

    /**
     * Build a bar chart for a given array of counts.  Bars are spaced along the x
     * axis relative to an offset and scaled according to a global maximum.  Each
     * bar group also includes simple x/y axes.  Colours are supplied per
     * distribution.
     *
     * @param {Array<number>} counts - An array of bin counts
     * @param {number} offsetX - The x offset where this chart starts
     * @param {number} colour - The colour to use for the bars
     */
    function addDistributionBars(counts, offsetX, colour) {
      const group = new THREE.Group();
      counts.forEach((count, idx) => {
        const height = (count / maxCount) * 20.0 + 0.1; // scale and avoid zero height
        const bar = createBar(height, colour);
        const x = offsetX + idx * barSpacing + barWidth / 2.0;
        bar.position.x = x;
        group.add(bar);
      });
      const groupWidth = counts.length * barSpacing;
      const axes = createAxes(groupWidth, 20.0, offsetX);
      group.add(axes);
      scene.add(group);
    }

    // Add the three distribution bar charts.  Colours were chosen to reflect the
    // orange tone of Blaze (monthly), a teal tone for ROI and a violet tone for
    // profit margin.  These colours differentiate the charts while retaining
    // sufficient contrast against the dark background.
    addDistributionBars(data.monthly.counts,     monthlyOffset, 0xff8c00);
    addDistributionBars(data.roi.counts,         roiOffset,     0x20b2aa);
    addDistributionBars(data.profit_margin.counts, pmOffset,    0x8a2be2);

    /**
     * Render a mean revenue bar chart.  The four revenue streams (Subscription,
     * API, Projects, Licensing) are mapped to bars whose heights are scaled by
     * the maximum revenue value.  A colour hue is chosen based on the bar
     * index to provide a pleasing gradient across the group.  An axis is added
     * beneath the bars to ground them visually.
     *
     * @param {Object} means - A mapping of revenue stream names to mean values
     * @param {number} offsetX - The x offset where this chart starts
     */
    function addRevenueBars(means, offsetX) {
      const group = new THREE.Group();
      const values = Object.values(means);
      const names  = Object.keys(means);
      values.forEach((val, idx) => {
        const height = (val / maxRevenue) * 20.0 + 0.1;
        const hue = idx / values.length;
        const colour = new THREE.Color().setHSL(hue, 0.6, 0.5);
        const bar = createBar(height, colour);
        const x = offsetX + idx * barSpacing + barWidth / 2.0;
        bar.position.x = x;
        group.add(bar);
      });
      const groupWidth = values.length * barSpacing;
      const axes = createAxes(groupWidth, 20.0, offsetX);
      group.add(axes);
      scene.add(group);
    }
    addRevenueBars(data.mean_revenues, revenueOffset);

    /**
     * Render a sensitivity bar chart.  Each factor's impact score is scaled by
     * the maximum score observed.  Colours vary with the factor index along a
     * spectrum from red/orange through yellow to green, providing immediate
     * visual differentiation of relative importance.
     *
     * @param {Array<string>} factors - Names of the factors analysed
     * @param {Array<number|string>} scores - Impact scores corresponding to each factor
     * @param {number} offsetX - The x offset where this chart starts
     */
    function addSensitivityBars(factors, scores, offsetX) {
      const group = new THREE.Group();
      scores.forEach((s, idx) => {
        const score = Number(s);
        const height = (score / maxSens) * 20.0 + 0.1;
        // Colour gradient ranging from red/orange to green.  Hues from 0.05 to 0.33
        const hue = 0.05 + 0.28 * (idx / scores.length);
        const colour = new THREE.Color().setHSL(hue, 0.65, 0.45);
        const bar = createBar(height, colour);
        const x = offsetX + idx * barSpacing + barWidth / 2.0;
        bar.position.x = x;
        group.add(bar);
      });
      const groupWidth = scores.length * barSpacing;
      const axes = createAxes(groupWidth, 20.0, offsetX);
      group.add(axes);
      scene.add(group);
    }
    addSensitivityBars(data.sensitivity.factors, data.sensitivity.impact_scores, sensOffset);

    // Handle resizing of the browser window by updating camera aspect ratio
    // and renderer dimensions.  This keeps the scene correctly proportioned.
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop.  requestAnimationFrame ensures the scene is re-rendered
    // at the display refresh rate.  The orbit controls are updated each
    // frame to apply damping when the user interacts with the scene.
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>